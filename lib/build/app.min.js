var XB =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/js/2d_grid/grid_2d.js":
/*!***********************************!*\
  !*** ./lib/js/2d_grid/grid_2d.js ***!
  \***********************************/
/*! exports provided: Grid2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Grid2D\", function() { return Grid2D; });\nclass Grid2D {\n  constructor() {\n    this.scrollTop = document.documentElement.scrollTop;\n    this.needsUpdate = true;\n    this.step = 64;\n\n    // doc\n    this.cvs = document.createElement('canvas');\n    this.ctx = this.cvs.getContext('2d');\n    this.cvs.classList.add('canvas-2d');\n    this.ctx.imageSmoothingEnabled = false;\n    this.target = {\n      doc: document.documentElement,\n      sections: null\n    };\n    this.resize();\n    document.body.appendChild(this.cvs);\n  }\n\n  onscroll() {\n    if (this.target.doc.scrollTop != this.scrollTop) {\n      this.scrollTop = this.target.doc.scrollTop;\n      this.needsUpdate = true;\n    }\n  }\n\n  handleMouse(x, y) {}\n\n  resize() {\n    this.cvs.width = window.innerWidth;\n    this.cvs.height = window.innerHeight;\n    this.needsUpdate = true;\n    this.target.sections = Array.from(document.querySelectorAll('.section')).map(e => {\n      const rect = e.getBoundingClientRect();\n      return { x: rect.left, y: rect.top };\n    });\n  }\n\n  drawGrid() {\n    var ystart = -(this.scrollTop % this.step);\n    var xstart = 0;\n    this.ctx.fillStyle = '#00f';\n    for (var y = ystart, ylim = this.cvs.height; y < ylim; y += this.step) {\n      this.ctx.fillRect(0, y, this.cvs.width, 1);\n    }\n    for (var x = xstart, xlim = this.cvs.width; x < xlim; x += this.step) {\n      this.ctx.fillRect(x, 0, 1, this.cvs.height);\n    }\n\n    for (var i = 0, len = this.target.sections.length; i < len; ++i) {\n      const coord = this.target.sections[i];\n      if (coord.y > 0 && coord.y < this.cvs.height) {\n        const x = xstart + (coord.x - coord.x % this.step);\n        const y = ystart + (coord.y - coord.y % this.step);\n        this.ctx.fillRect(x, y, this.step / 2, this.step / 2);\n      }\n    }\n  }\n\n  update(delta) {\n    if (this.needsUpdate) {\n      this.ctx.clearRect(0, 0, this.cvs.width, this.cvs.height);\n      this.drawGrid();\n      this.needsUpdate = false;\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/2d_grid/grid_2d.js?");

/***/ }),

/***/ "./lib/js/2d_grid/index.js":
/*!*********************************!*\
  !*** ./lib/js/2d_grid/index.js ***!
  \*********************************/
/*! exports provided: Grid2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _grid_2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grid_2d */ \"./lib/js/2d_grid/grid_2d.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Grid2D\", function() { return _grid_2d__WEBPACK_IMPORTED_MODULE_0__[\"Grid2D\"]; });\n\n\n\n//# sourceURL=webpack://XB/./lib/js/2d_grid/index.js?");

/***/ }),

/***/ "./lib/js/3d_grid/box_handler.js":
/*!***************************************!*\
  !*** ./lib/js/3d_grid/box_handler.js ***!
  \***************************************/
/*! exports provided: BoxHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxHandler\", function() { return BoxHandler; });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom */ \"./lib/js/dom/index.js\");\n/**\r\n * Generic bounding box functions.\r\n */\n\n\n\nclass BoxHandler {\n  constructor(camera) {\n    this.camera = camera;\n    this.reset();\n  }\n\n  reset() {\n    return;\n\n    // create list\n    this.boxes = [];\n    document.querySelectorAll('.box.active').forEach(e => {\n      if (this.onScreen(e)) {\n        this.boxes.push(new _dom__WEBPACK_IMPORTED_MODULE_0__[\"Box\"](e, this.camera));\n      }\n    });\n    this.active = true;\n  }\n\n  onScreen(e) {\n    // check is element is onscreen\n    const rect = e.getBoundingClientRect();\n    const L = rect.left;\n    const R = L + rect.width;\n    const T = rect.top;\n    const B = T + rect.height;\n    return (L < window.innerWidth || R > 0) && T < window.innerHeight && B > 0;\n  }\n\n  update() {\n    return;\n    for (let i = 0; i < this.boxes.length; i++) {\n      this.boxes[i].update();\n    }\n    this.active = true;\n  }\n\n  deactivate() {\n    this.active = false;\n  }\n\n  isActive() {\n    return this.active;\n  }\n\n  getBoxes() {\n    return this.boxes;\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/3d_grid/box_handler.js?");

/***/ }),

/***/ "./lib/js/3d_grid/camera.js":
/*!**********************************!*\
  !*** ./lib/js/3d_grid/camera.js ***!
  \**********************************/
/*! exports provided: Camera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return Camera; });\n/**\r\n * Orthographic camera, convert between world and screen space.\r\n */\n\nclass Camera {\n  constructor(width, height) {\n    this.size = 6;\n    this.width = this.size * (width / height);\n    this.height = this.size;\n    this.near = 1;\n    this.far = 1000;\n    this.camera = new THREE.OrthographicCamera(-this.width, this.width, this.height, -this.height, this.near, this.far);\n    this.camera.updateProjectionMatrix();\n    this.domOffset = 120;\n    this.distance = 20;\n    this.age = Math.PI * 0.25;\n    this.position = new THREE.Vector3(Math.sin(this.age) * this.distance, this.distance, Math.cos(this.age) * this.distance);\n    this.camera.position.set(this.position.x, this.position.y, this.position.z);\n    this.camera.lookAt(new THREE.Vector3(0, 0, 0));\n\n    // raycasting\n    this.intersectPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0));\n    this.raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n  }\n\n  update(delta) {\n    //this.age += delta * 0.1;\n    //this.position = new THREE.Vector3(Math.sin(this.age) * this.distance, this.distance * 2, Math.cos(this.age) * this.distance);\n    //this.camera.position.set(this.position.x, this.position.y, this.position.z);\n    //this.camera.lookAt(new THREE.Vector3(0, 0, 0));\n  }\n\n  resize(width, height) {\n    this.width = this.size * (width / height);\n    this.camera.left = -this.width;\n    this.camera.right = this.width;\n    this.camera.updateProjectionMatrix();\n  }\n\n  toWorldSpace(x, y, target) {\n    // convert screen space coordinates to world space\n    this.mouse.x = x / window.innerWidth * 2 - 1;\n    this.mouse.y = -((y + this.domOffset) / window.innerHeight) * 2 + 1;\n    this.raycaster.setFromCamera(this.mouse, this.camera);\n    this.raycaster.ray.intersectPlane(this.intersectPlane, target);\n  }\n\n  getCamera() {\n    return this.camera;\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/3d_grid/camera.js?");

/***/ }),

/***/ "./lib/js/3d_grid/cell.js":
/*!********************************!*\
  !*** ./lib/js/3d_grid/cell.js ***!
  \********************************/
/*! exports provided: Cell */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cell\", function() { return Cell; });\n/**\r\n * An interactive grid cell.\r\n */\n\nclass Cell {\n  constructor(x, z, radius) {\n    // interactive cell\n    this.group = new THREE.Group();\n    this.base = new THREE.Vector3(x, Math.random() * 0.5 - 0.55, z);\n    this.position = this.base.clone();\n    this.target = {\n      position: this.base.clone(),\n      rotation: new THREE.Vector3(),\n      scale: new THREE.Vector3(1, 1, 1)\n    };\n    this.maxHeight = 1 - 2 * (radius - 0.3);\n    this.mouseRadius = 2;\n\n    // add components to group\n    this.radius = radius / 2 + Math.random() * radius / 2;\n    const sides = Math.round(Math.random() * 4) + 4;\n    const mat = new THREE.ShaderMaterial(THREE.DepthShader);\n    const cylinder = new THREE.Mesh(new THREE.CylinderBufferGeometry(this.radius, this.radius, 4, sides), mat);\n    //const cap = new THREE.Mesh(new THREE.SphereBufferGeometry(this.radius, sides, sides), mat);\n    //cap.position.set(0, 2, 0);\n    this.group.add(cylinder);\n    //this.group.add(cap);\n    this.group.position.set(this.position.x, this.position.y, this.position.z);\n    this.group.rotation.y = Math.random() * Math.PI;\n\n    // logic set up\n    this.age = 0;\n    this.adjust = 0.05;\n    this.excited = false;\n    this.sway = Math.random() * Math.PI * 2;\n  }\n\n  collision(boxes) {\n    // set rotation and position targets\n    var collision = false;\n    for (var i = 0, len = boxes.length; i < len; ++i) {\n      if (boxes[i].collision(this.base)) {\n        collision = true;\n        break;\n      }\n    }\n    this.excited = collision;\n  }\n\n  tween(from, to, amount) {\n    from.x += (to.x - from.x) * amount;\n    from.y += (to.y - from.y) * amount;\n    from.z += (to.z - from.z) * amount;\n  }\n\n  update(delta, mouse) {\n    // update cell\n    this.age += delta;\n\n    // set position & rotation\n    this.tween(this.group.position, this.target.position, this.adjust);\n    this.tween(this.group.scale, this.target.scale, this.adjust);\n\n    if (this.excited || this.base.distanceTo(mouse) < this.mouseRadius) {\n      this.target.scale.z = 0.5;\n      this.target.scale.x = 0.5;\n      this.target.position.y = this.maxHeight;\n      this.group.rotation.x += (Math.random() - 0.5) * 0.04;\n      this.group.rotation.y += (Math.random() - 0.5) * 0.04;\n    } else {\n      this.target.scale.z = 1;\n      this.target.scale.x = 1;\n      const yfactor = Math.sin(this.age + (this.base.x + this.base.z + this.sway));\n      this.target.position.y = this.base.y;\n      if (Math.abs(this.group.rotation.x) > 0.1) {\n        this.group.rotation.x *= 0.9;\n      }\n      this.group.rotation.y += Math.sin(this.age + (this.base.x + this.base.z + this.sway)) * 0.002;\n      this.group.rotation.x += Math.cos(this.age + (this.base.x + this.sway)) * 0.002;\n    }\n  }\n\n  getMesh() {\n    return this.group;\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/3d_grid/cell.js?");

/***/ }),

/***/ "./lib/js/3d_grid/grid_3d.js":
/*!***********************************!*\
  !*** ./lib/js/3d_grid/grid_3d.js ***!
  \***********************************/
/*! exports provided: Grid3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Grid3D\", function() { return Grid3D; });\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer */ \"./lib/js/3d_grid/renderer.js\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ \"./lib/js/3d_grid/camera.js\");\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scene */ \"./lib/js/3d_grid/scene.js\");\n/* harmony import */ var _box_handler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./box_handler */ \"./lib/js/3d_grid/box_handler.js\");\n/**\r\n * Handle scene logic and rendering.\r\n */\n\n\n\n\n\n\nclass Grid3D {\n  constructor() {\n    this.isMobile = window.mobileCheck();\n    this.scene = new _scene__WEBPACK_IMPORTED_MODULE_2__[\"Scene\"]();\n    this.camera = new _camera__WEBPACK_IMPORTED_MODULE_1__[\"Camera\"](960, 540);\n    this.renderer = new _renderer__WEBPACK_IMPORTED_MODULE_0__[\"Renderer\"](this.scene.getScene(), this.camera.getCamera());\n    this.resize();\n\n    // add to doc\n    document.body.appendChild(this.renderer.renderer.domElement);\n\n    // logic\n    this.mouse = new THREE.Vector3(-100, 0, -100);\n    this.boxHandler = new _box_handler__WEBPACK_IMPORTED_MODULE_3__[\"BoxHandler\"](this.camera);\n\n    // timing\n    this.age = 0;\n    this.paused = false;\n    this.fps = 24;\n    this.frameInterval = 1 / this.fps;\n  }\n\n  reset() {\n    if (this.boxHandler) {\n      this.boxHandler.reset();\n    }\n  }\n\n  resize() {\n    // resize app\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    this.renderer.resize(width, height);\n    this.camera.resize(width, height);\n\n    // set state\n    if (this.boxHandler) {\n      this.boxHandler.update();\n    }\n  }\n\n  handleMouse(x, y) {\n    this.camera.toWorldSpace(x, y, this.mouse);\n  }\n\n  update(delta) {\n    this.age += delta;\n\n    if (this.age >= this.frameInterval) {\n      // update logic\n      if (this.boxHandler.isActive()) {\n        this.scene.collision(this.boxHandler.getBoxes());\n        this.boxHandler.deactivate();\n      }\n\n      this.scene.update(this.age, this.mouse);\n\n      // render\n      this.camera.update(this.age);\n      this.renderer.render(this.age);\n\n      // reset\n      this.age -= this.frameInterval;\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/3d_grid/grid_3d.js?");

/***/ }),

/***/ "./lib/js/3d_grid/index.js":
/*!*********************************!*\
  !*** ./lib/js/3d_grid/index.js ***!
  \*********************************/
/*! exports provided: Grid3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _grid_3d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grid_3d */ \"./lib/js/3d_grid/grid_3d.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Grid3D\", function() { return _grid_3d__WEBPACK_IMPORTED_MODULE_0__[\"Grid3D\"]; });\n\n\n\n//# sourceURL=webpack://XB/./lib/js/3d_grid/index.js?");

/***/ }),

/***/ "./lib/js/3d_grid/renderer.js":
/*!************************************!*\
  !*** ./lib/js/3d_grid/renderer.js ***!
  \************************************/
/*! exports provided: Renderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Renderer\", function() { return Renderer; });\n/**\r\n * Renders the scene.\r\n */\n\nclass Renderer {\n  constructor(scene, camera) {\n    this.scene = scene;\n    this.camera = camera;\n    this.mode = 'dev';\n    this.width = this.mode == 'dev' ? 960 : window.innerWidth;\n    this.height = this.mode == 'dev' ? 540 : window.innerHeight;\n    this.size = new THREE.Vector2(this.width, this.height);\n    this.renderer = new THREE.WebGLRenderer({ antialias: true });\n    this.renderer.setSize(this.width, this.height);\n    //this.renderer.setClearColor(0x0, 1);\n\n    // post-processing\n    this.pass = {\n      render: new THREE.RenderPass(this.scene, this.camera),\n      bloom: new THREE.UnrealBloomPass(new THREE.Vector2(this.width, this.height), 1.0, 1.2, 0.95)\n    };\n    this.pass.render.renderToScreen = true;\n    this.composer = new THREE.EffectComposer(this.renderer);\n    this.composer.addPass(this.pass.render);\n    //this.composer.addPass(this.pass.bloom);\n  }\n\n  resize(width, height) {\n    this.width = width;\n    this.height = height;\n    this.renderer.setSize(width, height);\n    this.composer.setSize(width, height);\n    this.pass.bloom.setSize(width, height);\n  }\n\n  render(delta) {\n    this.composer.render(delta);\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/3d_grid/renderer.js?");

/***/ }),

/***/ "./lib/js/3d_grid/scene.js":
/*!*********************************!*\
  !*** ./lib/js/3d_grid/scene.js ***!
  \*********************************/
/*! exports provided: Scene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ \"./lib/js/3d_grid/cell.js\");\n/**\r\n * Scene containing grid and cells. Handles animation.\r\n */\n\n\n\nclass Scene {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.createGrid();\n    this.plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(100, 100), new THREE.MeshBasicMaterial({ color: 0xffffff }));\n    this.plane.rotation.x = Math.PI * 1.5;\n    this.plane.position.y = 0;\n    this.scene.add(this.plane);\n\n    // lighting\n    const light = new THREE.PointLight(0xffffff, 1, 100, 2);\n    light.position.set(0, 2, 0);\n    this.scene.add(light);\n  }\n\n  createGrid() {\n    const n = 24;\n    const rot = Math.PI * 0.25;\n    const step = 1.1;\n    const nodeRadius = 0.4;\n    const cutoff = 19;\n    const origin = new THREE.Vector3();\n\n    // add cells\n    this.grid = [];\n    for (var x = -n; x < n; ++x) {\n      for (var z = -n; z < n; ++z) {\n        const coords = new THREE.Vector2(x * step, z * step);\n        if (coords.distanceTo(origin) < cutoff) {\n          const cell = new _cell__WEBPACK_IMPORTED_MODULE_0__[\"Cell\"](coords.x, coords.y, nodeRadius);\n          this.grid.push(cell);\n          this.scene.add(cell.getMesh());\n        }\n      }\n    }\n  }\n\n  collision(boxes) {\n    for (var i = 0, len = this.grid.length; i < len; ++i) {\n      this.grid[i].collision(boxes);\n    }\n  }\n\n  update(delta, mouse) {\n    for (var i = 0, len = this.grid.length; i < len; i++) {\n      this.grid[i].update(delta, mouse);\n    }\n  }\n\n  getScene() {\n    return this.scene;\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/3d_grid/scene.js?");

/***/ }),

/***/ "./lib/js/dom/box.js":
/*!***************************!*\
  !*** ./lib/js/dom/box.js ***!
  \***************************/
/*! exports provided: Box */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box\", function() { return Box; });\n/* harmony import */ var _maths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maths */ \"./lib/js/maths/index.js\");\n/**\r\n * World-space bounding-box corresponding to a screen-space dom element.\r\n */\n\n\n\nclass Box {\n  constructor(elem, camera) {\n    this.elem = elem;\n    this.camera = camera;\n\n    // corners\n    this.position = new THREE.Vector3();\n    this.a = new THREE.Vector3();\n    this.b = new THREE.Vector3();\n    this.c = new THREE.Vector3();\n    this.d = new THREE.Vector3();\n    this.setPoints();\n  }\n\n  update() {\n    this.setPoints();\n  }\n\n  setPoints() {\n    // set position in world space\n    const box = this.elem.getBoundingClientRect();\n    const L = box.left;\n    const T = box.top;\n    const W = box.width;\n    const H = box.height;\n    const X = L + W / 2;\n    const Y = T + H / 2;\n\n    // convert\n    this.camera.toWorldSpace(X, Y, this.position);\n    this.camera.toWorldSpace(L, Y, this.a);\n    this.camera.toWorldSpace(L + W, Y, this.b);\n    this.camera.toWorldSpace(X, T, this.c);\n    this.camera.toWorldSpace(X, T + H, this.d);\n\n    // set normals\n    this.normal = {};\n    this.normal.a = this.a.clone().sub(this.position);\n    this.normal.b = this.b.clone().sub(this.position);\n    this.normal.c = this.c.clone().sub(this.position);\n    this.normal.d = this.d.clone().sub(this.position);\n  }\n\n  collision(point) {\n    return Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"dot2D\"])(Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"subVector\"])(this.a, point), this.normal.a) >= 0 && Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"dot2D\"])(Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"subVector\"])(this.b, point), this.normal.b) >= 0 && Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"dot2D\"])(Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"subVector\"])(this.c, point), this.normal.c) >= 0 && Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"dot2D\"])(Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"subVector\"])(this.d, point), this.normal.d) >= 0;\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/dom/box.js?");

/***/ }),

/***/ "./lib/js/dom/circle.js":
/*!******************************!*\
  !*** ./lib/js/dom/circle.js ***!
  \******************************/
/*! exports provided: Circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Circle\", function() { return Circle; });\nclass Circle {\n  constructor(position, radius) {\n    this.position = position;\n    this.radius = radius;\n  }\n\n  update() {}\n\n  collision(point) {\n    return point.distanceTo(this.position) < this.radius;\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/dom/circle.js?");

/***/ }),

/***/ "./lib/js/dom/index.js":
/*!*****************************!*\
  !*** ./lib/js/dom/index.js ***!
  \*****************************/
/*! exports provided: Box, Circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./box */ \"./lib/js/dom/box.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Box\", function() { return _box__WEBPACK_IMPORTED_MODULE_0__[\"Box\"]; });\n\n/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./circle */ \"./lib/js/dom/circle.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Circle\", function() { return _circle__WEBPACK_IMPORTED_MODULE_1__[\"Circle\"]; });\n\n\n\n\n//# sourceURL=webpack://XB/./lib/js/dom/index.js?");

/***/ }),

/***/ "./lib/js/lib/index.js":
/*!*****************************!*\
  !*** ./lib/js/lib/index.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _postprocessing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./postprocessing */ \"./lib/js/lib/postprocessing/index.js\");\n/* harmony import */ var _mobile_check_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mobile_check.js */ \"./lib/js/lib/mobile_check.js\");\n/* harmony import */ var _mobile_check_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mobile_check_js__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n//# sourceURL=webpack://XB/./lib/js/lib/index.js?");

/***/ }),

/***/ "./lib/js/lib/mobile_check.js":
/*!************************************!*\
  !*** ./lib/js/lib/mobile_check.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("window.mobileCheck = function () {\n  var check = false;\n  (function (a) {\n    if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true;\n  })(navigator.userAgent || navigator.vendor || window.opera);\n  return check;\n};\n\n//# sourceURL=webpack://XB/./lib/js/lib/mobile_check.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/CopyShader.js":
/*!*************************************************!*\
  !*** ./lib/js/lib/postprocessing/CopyShader.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Full-screen textured quad shader\r\n */\n\nTHREE.CopyShader = {\n\n\t\tuniforms: {\n\n\t\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\t\"opacity\": { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\t\tfragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"gl_FragColor = opacity * texel;\", \"}\"].join(\"\\n\")\n\n};\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/CopyShader.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/DepthShader.js":
/*!**************************************************!*\
  !*** ./lib/js/lib/postprocessing/DepthShader.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n  @author meatbags / https://github.com/meatbags\r\n  **/\n\nTHREE.DepthShader = {\n  uniforms: {},\n  vertexShader: `\n    varying vec4 vModel;\n    varying vec3 vNormal;\n\n    void main() {\n      vNormal = normal;\n      vModel = modelMatrix * vec4(position, 1.0);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    varying vec4 vModel;\n    varying vec3 vNormal;\n    \n    void main() {\n      float y = (vModel.y >= 0.0) ? (vModel.y) / 5.0 : 0.0;\n      float r = 1.0 - y * 1.0;\n      float g = 1.0 - y * 1.0;\n      float b = 1.0 - y * 1.0;\n      gl_FragColor = vec4(r, g, b, vModel.w);\n    }\n  `\n};\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/DepthShader.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/EffectComposer.js":
/*!*****************************************************!*\
  !*** ./lib/js/lib/postprocessing/EffectComposer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.EffectComposer = function (renderer, renderTarget) {\n\n\tthis.renderer = renderer;\n\n\tif (renderTarget === undefined) {\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar size = renderer.getDrawingBufferSize();\n\t\trenderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);\n\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.passes = [];\n\n\t// dependencies\n\n\tif (THREE.CopyShader === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.CopyShader');\n\t}\n\n\tif (THREE.ShaderPass === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.ShaderPass');\n\t}\n\n\tthis.copyPass = new THREE.ShaderPass(THREE.CopyShader);\n};\n\nObject.assign(THREE.EffectComposer.prototype, {\n\n\tswapBuffers: function () {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\t},\n\n\taddPass: function (pass) {\n\n\t\tthis.passes.push(pass);\n\n\t\tvar size = this.renderer.getDrawingBufferSize();\n\t\tpass.setSize(size.width, size.height);\n\t},\n\n\tinsertPass: function (pass, index) {\n\n\t\tthis.passes.splice(index, 0, pass);\n\t},\n\n\trender: function (delta) {\n\n\t\tvar maskActive = false;\n\n\t\tvar pass,\n\t\t    i,\n\t\t    il = this.passes.length;\n\n\t\tfor (i = 0; i < il; i++) {\n\n\t\t\tpass = this.passes[i];\n\n\t\t\tif (pass.enabled === false) continue;\n\n\t\t\tpass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);\n\n\t\t\tif (pass.needsSwap) {\n\n\t\t\t\tif (maskActive) {\n\n\t\t\t\t\tvar context = this.renderer.context;\n\n\t\t\t\t\tcontext.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);\n\n\t\t\t\t\tthis.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);\n\n\t\t\t\t\tcontext.stencilFunc(context.EQUAL, 1, 0xffffffff);\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\t\t\t}\n\n\t\t\tif (THREE.MaskPass !== undefined) {\n\n\t\t\t\tif (pass instanceof THREE.MaskPass) {\n\n\t\t\t\t\tmaskActive = true;\n\t\t\t\t} else if (pass instanceof THREE.ClearMaskPass) {\n\n\t\t\t\t\tmaskActive = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\treset: function (renderTarget) {\n\n\t\tif (renderTarget === undefined) {\n\n\t\t\tvar size = this.renderer.getDrawingBufferSize();\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize(size.width, size.height);\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\t},\n\n\tsetSize: function (width, height) {\n\n\t\tthis.renderTarget1.setSize(width, height);\n\t\tthis.renderTarget2.setSize(width, height);\n\n\t\tfor (var i = 0; i < this.passes.length; i++) {\n\n\t\t\tthis.passes[i].setSize(width, height);\n\t\t}\n\t}\n\n});\n\nTHREE.Pass = function () {\n\n\t// if set to true, the pass is processed by the composer\n\tthis.enabled = true;\n\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\tthis.needsSwap = true;\n\n\t// if set to true, the pass clears its buffer before rendering\n\tthis.clear = false;\n\n\t// if set to true, the result of the pass is rendered to screen\n\tthis.renderToScreen = false;\n};\n\nObject.assign(THREE.Pass.prototype, {\n\n\tsetSize: function (width, height) {},\n\n\trender: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tconsole.error('THREE.Pass: .render() must be implemented in derived pass.');\n\t}\n\n});\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/EffectComposer.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/FXAA.js":
/*!*******************************************!*\
  !*** ./lib/js/lib/postprocessing/FXAA.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author davidedc / http://www.sketchpatch.net/\r\n *\r\n * NVIDIA FXAA by Timothy Lottes\r\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\r\n * - WebGL port by @supereggbert\r\n * http://www.glge.org/demos/fxaa/\r\n */\n\nTHREE.FXAAShader = {\n\n  uniforms: {\n\n    \"tDiffuse\": { value: null },\n    \"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n  },\n\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n  fragmentShader: [\"precision highp float;\", \"\", \"uniform sampler2D tDiffuse;\", \"\", \"uniform vec2 resolution;\", \"\", \"varying vec2 vUv;\", \"\", \"// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\", \"\", \"//----------------------------------------------------------------------------------\", \"// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\", \"// SDK Version: v3.00\", \"// Email:       gameworks@nvidia.com\", \"// Site:        http://developer.nvidia.com/\", \"//\", \"// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\", \"//\", \"// Redistribution and use in source and binary forms, with or without\", \"// modification, are permitted provided that the following conditions\", \"// are met:\", \"//  * Redistributions of source code must retain the above copyright\", \"//    notice, this list of conditions and the following disclaimer.\", \"//  * Redistributions in binary form must reproduce the above copyright\", \"//    notice, this list of conditions and the following disclaimer in the\", \"//    documentation and/or other materials provided with the distribution.\", \"//  * Neither the name of NVIDIA CORPORATION nor the names of its\", \"//    contributors may be used to endorse or promote products derived\", \"//    from this software without specific prior written permission.\", \"//\", \"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\", \"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\", \"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\", \"// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\", \"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\", \"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\", \"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\", \"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\", \"// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\", \"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\", \"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\", \"//\", \"//----------------------------------------------------------------------------------\", \"\", \"#define FXAA_PC 1\", \"#define FXAA_GLSL_100 1\", \"#define FXAA_QUALITY_PRESET 12\", \"\", \"#define FXAA_GREEN_AS_LUMA 1\", \"\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_PC_CONSOLE\", \"    //\", \"    // The console algorithm for PC is included\", \"    // for developers targeting really low spec machines.\", \"    // Likely better to just run FXAA_PC, and use a really low preset.\", \"    //\", \"    #define FXAA_PC_CONSOLE 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GLSL_120\", \"    #define FXAA_GLSL_120 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GLSL_130\", \"    #define FXAA_GLSL_130 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_3\", \"    #define FXAA_HLSL_3 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_4\", \"    #define FXAA_HLSL_4 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_5\", \"    #define FXAA_HLSL_5 0\", \"#endif\", \"/*==========================================================================*/\", \"#ifndef FXAA_GREEN_AS_LUMA\", \"    //\", \"    // For those using non-linear color,\", \"    // and either not able to get luma in alpha, or not wanting to,\", \"    // this enables FXAA to run using green as a proxy for luma.\", \"    // So with this enabled, no need to pack luma in alpha.\", \"    //\", \"    // This will turn off AA on anything which lacks some amount of green.\", \"    // Pure red and blue or combination of only R and B, will get no AA.\", \"    //\", \"    // Might want to lower the settings for both,\", \"    //    fxaaConsoleEdgeThresholdMin\", \"    //    fxaaQualityEdgeThresholdMin\", \"    // In order to insure AA does not get turned off on colors\", \"    // which contain a minor amount of green.\", \"    //\", \"    // 1 = On.\", \"    // 0 = Off.\", \"    //\", \"    #define FXAA_GREEN_AS_LUMA 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_EARLY_EXIT\", \"    //\", \"    // Controls algorithm's early exit path.\", \"    // On PS3 turning this ON adds 2 cycles to the shader.\", \"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\", \"    // Turning this off on console will result in a more blurry image.\", \"    // So this defaults to on.\", \"    //\", \"    // 1 = On.\", \"    // 0 = Off.\", \"    //\", \"    #define FXAA_EARLY_EXIT 1\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_DISCARD\", \"    //\", \"    // Only valid for PC OpenGL currently.\", \"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\", \"    //\", \"    // 1 = Use discard on pixels which don't need AA.\", \"    //     For APIs which enable concurrent TEX+ROP from same surface.\", \"    // 0 = Return unchanged color on pixels which don't need AA.\", \"    //\", \"    #define FXAA_DISCARD 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_FAST_PIXEL_OFFSET\", \"    //\", \"    // Used for GLSL 120 only.\", \"    //\", \"    // 1 = GL API supports fast pixel offsets\", \"    // 0 = do not use fast pixel offsets\", \"    //\", \"    #ifdef GL_EXT_gpu_shader4\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifdef GL_NV_gpu_shader5\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifdef GL_ARB_gpu_shader5\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifndef FXAA_FAST_PIXEL_OFFSET\", \"        #define FXAA_FAST_PIXEL_OFFSET 0\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GATHER4_ALPHA\", \"    //\", \"    // 1 = API supports gather4 on alpha channel.\", \"    // 0 = API does not support gather4 on alpha channel.\", \"    //\", \"    #if (FXAA_HLSL_5 == 1)\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifdef GL_ARB_gpu_shader5\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifdef GL_NV_gpu_shader5\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifndef FXAA_GATHER4_ALPHA\", \"        #define FXAA_GATHER4_ALPHA 0\", \"    #endif\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"                        FXAA QUALITY - TUNING KNOBS\", \"------------------------------------------------------------------------------\", \"NOTE the other tuning knobs are now in the shader function inputs!\", \"============================================================================*/\", \"#ifndef FXAA_QUALITY_PRESET\", \"    //\", \"    // Choose the quality preset.\", \"    // This needs to be compiled into the shader as it effects code.\", \"    // Best option to include multiple presets is to\", \"    // in each shader define the preset, then include this file.\", \"    //\", \"    // OPTIONS\", \"    // -----------------------------------------------------------------------\", \"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\", \"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\", \"    // 39       - no dither, very expensive\", \"    //\", \"    // NOTES\", \"    // -----------------------------------------------------------------------\", \"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\", \"    // 13 = about same speed as FXAA 3.9 and better than 12\", \"    // 23 = closest to FXAA 3.9 visually and performance wise\", \"    //  _ = the lowest digit is directly related to performance\", \"    // _  = the highest digit is directly related to style\", \"    //\", \"    #define FXAA_QUALITY_PRESET 12\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"\", \"                           FXAA QUALITY - PRESETS\", \"\", \"============================================================================*/\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - MEDIUM DITHER PRESETS\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 10)\", \"    #define FXAA_QUALITY_PS 3\", \"    #define FXAA_QUALITY_P0 1.5\", \"    #define FXAA_QUALITY_P1 3.0\", \"    #define FXAA_QUALITY_P2 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 11)\", \"    #define FXAA_QUALITY_PS 4\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 3.0\", \"    #define FXAA_QUALITY_P3 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 12)\", \"    #define FXAA_QUALITY_PS 5\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 4.0\", \"    #define FXAA_QUALITY_P4 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 13)\", \"    #define FXAA_QUALITY_PS 6\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 4.0\", \"    #define FXAA_QUALITY_P5 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 14)\", \"    #define FXAA_QUALITY_PS 7\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 4.0\", \"    #define FXAA_QUALITY_P6 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 15)\", \"    #define FXAA_QUALITY_PS 8\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 4.0\", \"    #define FXAA_QUALITY_P7 12.0\", \"#endif\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - LOW DITHER PRESETS\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 20)\", \"    #define FXAA_QUALITY_PS 3\", \"    #define FXAA_QUALITY_P0 1.5\", \"    #define FXAA_QUALITY_P1 2.0\", \"    #define FXAA_QUALITY_P2 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 21)\", \"    #define FXAA_QUALITY_PS 4\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 22)\", \"    #define FXAA_QUALITY_PS 5\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 23)\", \"    #define FXAA_QUALITY_PS 6\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 24)\", \"    #define FXAA_QUALITY_PS 7\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 3.0\", \"    #define FXAA_QUALITY_P6 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 25)\", \"    #define FXAA_QUALITY_PS 8\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 4.0\", \"    #define FXAA_QUALITY_P7 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 26)\", \"    #define FXAA_QUALITY_PS 9\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 4.0\", \"    #define FXAA_QUALITY_P8 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 27)\", \"    #define FXAA_QUALITY_PS 10\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 4.0\", \"    #define FXAA_QUALITY_P9 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 28)\", \"    #define FXAA_QUALITY_PS 11\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 4.0\", \"    #define FXAA_QUALITY_P10 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 29)\", \"    #define FXAA_QUALITY_PS 12\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 2.0\", \"    #define FXAA_QUALITY_P10 4.0\", \"    #define FXAA_QUALITY_P11 8.0\", \"#endif\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - EXTREME QUALITY\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 39)\", \"    #define FXAA_QUALITY_PS 12\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.0\", \"    #define FXAA_QUALITY_P2 1.0\", \"    #define FXAA_QUALITY_P3 1.0\", \"    #define FXAA_QUALITY_P4 1.0\", \"    #define FXAA_QUALITY_P5 1.5\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 2.0\", \"    #define FXAA_QUALITY_P10 4.0\", \"    #define FXAA_QUALITY_P11 8.0\", \"#endif\", \"\", \"\", \"\", \"/*============================================================================\", \"\", \"                                API PORTING\", \"\", \"============================================================================*/\", \"#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\", \"    #define FxaaBool bool\", \"    #define FxaaDiscard discard\", \"    #define FxaaFloat float\", \"    #define FxaaFloat2 vec2\", \"    #define FxaaFloat3 vec3\", \"    #define FxaaFloat4 vec4\", \"    #define FxaaHalf float\", \"    #define FxaaHalf2 vec2\", \"    #define FxaaHalf3 vec3\", \"    #define FxaaHalf4 vec4\", \"    #define FxaaInt2 ivec2\", \"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\", \"    #define FxaaTex sampler2D\", \"#else\", \"    #define FxaaBool bool\", \"    #define FxaaDiscard clip(-1)\", \"    #define FxaaFloat float\", \"    #define FxaaFloat2 float2\", \"    #define FxaaFloat3 float3\", \"    #define FxaaFloat4 float4\", \"    #define FxaaHalf half\", \"    #define FxaaHalf2 half2\", \"    #define FxaaHalf3 half3\", \"    #define FxaaHalf4 half4\", \"    #define FxaaSat(x) saturate(x)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_100 == 1)\", \"  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\", \"  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_120 == 1)\", \"    // Requires,\", \"    //  #version 120\", \"    // And at least,\", \"    //  #extension GL_EXT_gpu_shader4 : enable\", \"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\", \"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\", \"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\", \"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\", \"    #else\", \"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\", \"    #endif\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        // use #extension GL_ARB_gpu_shader5 : enable\", \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\", \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\", \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\", \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_130 == 1)\", \"    // Requires \\\"#version 130\\\" or better\", \"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        // use #extension GL_ARB_gpu_shader5 : enable\", \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\", \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\", \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\", \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_3 == 1)\", \"    #define FxaaInt2 float2\", \"    #define FxaaTex sampler2D\", \"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\", \"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_4 == 1)\", \"    #define FxaaInt2 int2\", \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\", \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_5 == 1)\", \"    #define FxaaInt2 int2\", \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\", \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\", \"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\", \"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\", \"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\", \"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"                   GREEN AS LUMA OPTION SUPPORT FUNCTION\", \"============================================================================*/\", \"#if (FXAA_GREEN_AS_LUMA == 0)\", \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\", \"#else\", \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\", \"#endif\", \"\", \"\", \"\", \"\", \"/*============================================================================\", \"\", \"                             FXAA3 QUALITY - PC\", \"\", \"============================================================================*/\", \"#if (FXAA_PC == 1)\", \"/*--------------------------------------------------------------------------*/\", \"FxaaFloat4 FxaaPixelShader(\", \"    //\", \"    // Use noperspective interpolation here (turn off perspective interpolation).\", \"    // {xy} = center of pixel\", \"    FxaaFloat2 pos,\", \"    //\", \"    // Used only for FXAA Console, and not used on the 360 version.\", \"    // Use noperspective interpolation here (turn off perspective interpolation).\", \"    // {xy_} = upper left of pixel\", \"    // {_zw} = lower right of pixel\", \"    FxaaFloat4 fxaaConsolePosPos,\", \"    //\", \"    // Input color texture.\", \"    // {rgb_} = color in linear or perceptual color space\", \"    // if (FXAA_GREEN_AS_LUMA == 0)\", \"    //     {__a} = luma in perceptual color space (not linear)\", \"    FxaaTex tex,\", \"    //\", \"    // Only used on the optimized 360 version of FXAA Console.\", \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\", \"    // For 360, same texture, just alias with a 2nd sampler.\", \"    // This sampler needs to have an exponent bias of -1.\", \"    FxaaTex fxaaConsole360TexExpBiasNegOne,\", \"    //\", \"    // Only used on the optimized 360 version of FXAA Console.\", \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\", \"    // For 360, same texture, just alias with a 3nd sampler.\", \"    // This sampler needs to have an exponent bias of -2.\", \"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This must be from a constant/uniform.\", \"    // {x_} = 1.0/screenWidthInPixels\", \"    // {_y} = 1.0/screenHeightInPixels\", \"    FxaaFloat2 fxaaQualityRcpFrame,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This must be from a constant/uniform.\", \"    // This effects sub-pixel AA quality and inversely sharpness.\", \"    //   Where N ranges between,\", \"    //     N = 0.50 (default)\", \"    //     N = 0.33 (sharper)\", \"    // {x__} = -N/screenWidthInPixels\", \"    // {_y_} = -N/screenHeightInPixels\", \"    // {_z_} =  N/screenWidthInPixels\", \"    // {__w} =  N/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // Not used on 360, but used on PS3 and PC.\", \"    // This must be from a constant/uniform.\", \"    // {x__} = -2.0/screenWidthInPixels\", \"    // {_y_} = -2.0/screenHeightInPixels\", \"    // {_z_} =  2.0/screenWidthInPixels\", \"    // {__w} =  2.0/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\", \"    // This must be from a constant/uniform.\", \"    // {x__} =  8.0/screenWidthInPixels\", \"    // {_y_} =  8.0/screenHeightInPixels\", \"    // {_z_} = -4.0/screenWidthInPixels\", \"    // {__w} = -4.0/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_SUBPIX define.\", \"    // It is here now to allow easier tuning.\", \"    // Choose the amount of sub-pixel aliasing removal.\", \"    // This can effect sharpness.\", \"    //   1.00 - upper limit (softer)\", \"    //   0.75 - default amount of filtering\", \"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\", \"    //   0.25 - almost off\", \"    //   0.00 - completely off\", \"    FxaaFloat fxaaQualitySubpix,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\", \"    // It is here now to allow easier tuning.\", \"    // The minimum amount of local contrast required to apply algorithm.\", \"    //   0.333 - too little (faster)\", \"    //   0.250 - low quality\", \"    //   0.166 - default\", \"    //   0.125 - high quality\", \"    //   0.063 - overkill (slower)\", \"    FxaaFloat fxaaQualityEdgeThreshold,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\", \"    // It is here now to allow easier tuning.\", \"    // Trims the algorithm from processing darks.\", \"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\", \"    //   0.0625 - high quality (faster)\", \"    //   0.0312 - visible limit (slower)\", \"    // Special notes when using FXAA_GREEN_AS_LUMA,\", \"    //   Likely want to set this to zero.\", \"    //   As colors that are mostly not-green\", \"    //   will appear very dark in the green channel!\", \"    //   Tune by looking at mostly non-green content,\", \"    //   then start at zero and increase until aliasing is a problem.\", \"    FxaaFloat fxaaQualityEdgeThresholdMin,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\", \"    // It is here now to allow easier tuning.\", \"    // This does not effect PS3, as this needs to be compiled in.\", \"    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\", \"    //   Due to the PS3 being ALU bound,\", \"    //   there are only three safe values here: 2 and 4 and 8.\", \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\", \"    // For all other platforms can be a non-power of two.\", \"    //   8.0 is sharper (default!!!)\", \"    //   4.0 is softer\", \"    //   2.0 is really soft (good only for vector graphics inputs)\", \"    FxaaFloat fxaaConsoleEdgeSharpness,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\", \"    // It is here now to allow easier tuning.\", \"    // This does not effect PS3, as this needs to be compiled in.\", \"    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\", \"    //   Due to the PS3 being ALU bound,\", \"    //   there are only two safe values here: 1/4 and 1/8.\", \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\", \"    // The console setting has a different mapping than the quality setting.\", \"    // Other platforms can use other values.\", \"    //   0.125 leaves less aliasing, but is softer (default!!!)\", \"    //   0.25 leaves more aliasing, and is sharper\", \"    FxaaFloat fxaaConsoleEdgeThreshold,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\", \"    // It is here now to allow easier tuning.\", \"    // Trims the algorithm from processing darks.\", \"    // The console setting has a different mapping than the quality setting.\", \"    // This only applies when FXAA_EARLY_EXIT is 1.\", \"    // This does not apply to PS3,\", \"    // PS3 was simplified to avoid more shader instructions.\", \"    //   0.06 - faster but more aliasing in darks\", \"    //   0.05 - default\", \"    //   0.04 - slower and less aliasing in darks\", \"    // Special notes when using FXAA_GREEN_AS_LUMA,\", \"    //   Likely want to set this to zero.\", \"    //   As colors that are mostly not-green\", \"    //   will appear very dark in the green channel!\", \"    //   Tune by looking at mostly non-green content,\", \"    //   then start at zero and increase until aliasing is a problem.\", \"    FxaaFloat fxaaConsoleEdgeThresholdMin,\", \"    //\", \"    // Extra constants for 360 FXAA Console only.\", \"    // Use zeros or anything else for other platforms.\", \"    // These must be in physical constant registers and NOT immedates.\", \"    // Immedates will result in compiler un-optimizing.\", \"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\", \"    FxaaFloat4 fxaaConsole360ConstDir\", \") {\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posM;\", \"    posM.x = pos.x;\", \"    posM.y = pos.y;\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        #if (FXAA_DISCARD == 0)\", \"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\", \"            #if (FXAA_GREEN_AS_LUMA == 0)\", \"                #define lumaM rgbyM.w\", \"            #else\", \"                #define lumaM rgbyM.y\", \"            #endif\", \"        #endif\", \"        #if (FXAA_GREEN_AS_LUMA == 0)\", \"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\", \"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\", \"        #else\", \"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\", \"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\", \"        #endif\", \"        #if (FXAA_DISCARD == 1)\", \"            #define lumaM luma4A.w\", \"        #endif\", \"        #define lumaE luma4A.z\", \"        #define lumaS luma4A.x\", \"        #define lumaSE luma4A.y\", \"        #define lumaNW luma4B.w\", \"        #define lumaN luma4B.z\", \"        #define lumaW luma4B.x\", \"    #else\", \"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\", \"        #if (FXAA_GREEN_AS_LUMA == 0)\", \"            #define lumaM rgbyM.w\", \"        #else\", \"            #define lumaM rgbyM.y\", \"        #endif\", \"        #if (FXAA_GLSL_100 == 1)\", \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\", \"        #else\", \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\", \"        #endif\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat maxSM = max(lumaS, lumaM);\", \"    FxaaFloat minSM = min(lumaS, lumaM);\", \"    FxaaFloat maxESM = max(lumaE, maxSM);\", \"    FxaaFloat minESM = min(lumaE, minSM);\", \"    FxaaFloat maxWN = max(lumaN, lumaW);\", \"    FxaaFloat minWN = min(lumaN, lumaW);\", \"    FxaaFloat rangeMax = max(maxWN, maxESM);\", \"    FxaaFloat rangeMin = min(minWN, minESM);\", \"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\", \"    FxaaFloat range = rangeMax - rangeMin;\", \"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\", \"    FxaaBool earlyExit = range < rangeMaxClamped;\", \"/*--------------------------------------------------------------------------*/\", \"    if(earlyExit)\", \"        #if (FXAA_DISCARD == 1)\", \"            FxaaDiscard;\", \"        #else\", \"            return rgbyM;\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    #if (FXAA_GATHER4_ALPHA == 0)\", \"        #if (FXAA_GLSL_100 == 1)\", \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\", \"        #else\", \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\", \"        #endif\", \"    #else\", \"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\", \"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNS = lumaN + lumaS;\", \"    FxaaFloat lumaWE = lumaW + lumaE;\", \"    FxaaFloat subpixRcpRange = 1.0/range;\", \"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\", \"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\", \"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNESE = lumaNE + lumaSE;\", \"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\", \"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\", \"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\", \"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\", \"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\", \"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\", \"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\", \"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\", \"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\", \"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\", \"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\", \"    FxaaBool horzSpan = edgeHorz >= edgeVert;\", \"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\", \"/*--------------------------------------------------------------------------*/\", \"    if(!horzSpan) lumaN = lumaW;\", \"    if(!horzSpan) lumaS = lumaE;\", \"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\", \"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat gradientN = lumaN - lumaM;\", \"    FxaaFloat gradientS = lumaS - lumaM;\", \"    FxaaFloat lumaNN = lumaN + lumaM;\", \"    FxaaFloat lumaSS = lumaS + lumaM;\", \"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\", \"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\", \"    if(pairN) lengthSign = -lengthSign;\", \"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posB;\", \"    posB.x = posM.x;\", \"    posB.y = posM.y;\", \"    FxaaFloat2 offNP;\", \"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\", \"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\", \"    if(!horzSpan) posB.x += lengthSign * 0.5;\", \"    if( horzSpan) posB.y += lengthSign * 0.5;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posN;\", \"    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\", \"    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\", \"    FxaaFloat2 posP;\", \"    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\", \"    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\", \"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\", \"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\", \"    FxaaFloat subpixE = subpixC * subpixC;\", \"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\", \"/*--------------------------------------------------------------------------*/\", \"    if(!pairN) lumaNN = lumaSS;\", \"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\", \"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\", \"    FxaaFloat subpixF = subpixD * subpixE;\", \"    FxaaBool lumaMLTZero = lumaMM < 0.0;\", \"/*--------------------------------------------------------------------------*/\", \"    lumaEndN -= lumaNN * 0.5;\", \"    lumaEndP -= lumaNN * 0.5;\", \"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\", \"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\", \"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\", \"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\", \"    FxaaBool doneNP = (!doneN) || (!doneP);\", \"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\", \"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\", \"/*--------------------------------------------------------------------------*/\", \"    if(doneNP) {\", \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"        doneN = abs(lumaEndN) >= gradientScaled;\", \"        doneP = abs(lumaEndP) >= gradientScaled;\", \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\", \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\", \"        doneNP = (!doneN) || (!doneP);\", \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\", \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\", \"/*--------------------------------------------------------------------------*/\", \"        #if (FXAA_QUALITY_PS > 3)\", \"        if(doneNP) {\", \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"            doneN = abs(lumaEndN) >= gradientScaled;\", \"            doneP = abs(lumaEndP) >= gradientScaled;\", \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\", \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\", \"            doneNP = (!doneN) || (!doneP);\", \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\", \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\", \"/*--------------------------------------------------------------------------*/\", \"            #if (FXAA_QUALITY_PS > 4)\", \"            if(doneNP) {\", \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                doneN = abs(lumaEndN) >= gradientScaled;\", \"                doneP = abs(lumaEndP) >= gradientScaled;\", \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\", \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\", \"                doneNP = (!doneN) || (!doneP);\", \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\", \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\", \"/*--------------------------------------------------------------------------*/\", \"                #if (FXAA_QUALITY_PS > 5)\", \"                if(doneNP) {\", \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                    doneN = abs(lumaEndN) >= gradientScaled;\", \"                    doneP = abs(lumaEndP) >= gradientScaled;\", \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\", \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\", \"                    doneNP = (!doneN) || (!doneP);\", \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\", \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\", \"/*--------------------------------------------------------------------------*/\", \"                    #if (FXAA_QUALITY_PS > 6)\", \"                    if(doneNP) {\", \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                        doneN = abs(lumaEndN) >= gradientScaled;\", \"                        doneP = abs(lumaEndP) >= gradientScaled;\", \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\", \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\", \"                        doneNP = (!doneN) || (!doneP);\", \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\", \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\", \"/*--------------------------------------------------------------------------*/\", \"                        #if (FXAA_QUALITY_PS > 7)\", \"                        if(doneNP) {\", \"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                            doneN = abs(lumaEndN) >= gradientScaled;\", \"                            doneP = abs(lumaEndP) >= gradientScaled;\", \"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\", \"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\", \"                            doneNP = (!doneN) || (!doneP);\", \"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\", \"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\", \"/*--------------------------------------------------------------------------*/\", \"    #if (FXAA_QUALITY_PS > 8)\", \"    if(doneNP) {\", \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"        doneN = abs(lumaEndN) >= gradientScaled;\", \"        doneP = abs(lumaEndP) >= gradientScaled;\", \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\", \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\", \"        doneNP = (!doneN) || (!doneP);\", \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\", \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\", \"/*--------------------------------------------------------------------------*/\", \"        #if (FXAA_QUALITY_PS > 9)\", \"        if(doneNP) {\", \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"            doneN = abs(lumaEndN) >= gradientScaled;\", \"            doneP = abs(lumaEndP) >= gradientScaled;\", \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\", \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\", \"            doneNP = (!doneN) || (!doneP);\", \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\", \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\", \"/*--------------------------------------------------------------------------*/\", \"            #if (FXAA_QUALITY_PS > 10)\", \"            if(doneNP) {\", \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                doneN = abs(lumaEndN) >= gradientScaled;\", \"                doneP = abs(lumaEndP) >= gradientScaled;\", \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\", \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\", \"                doneNP = (!doneN) || (!doneP);\", \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\", \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\", \"/*--------------------------------------------------------------------------*/\", \"                #if (FXAA_QUALITY_PS > 11)\", \"                if(doneNP) {\", \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                    doneN = abs(lumaEndN) >= gradientScaled;\", \"                    doneP = abs(lumaEndP) >= gradientScaled;\", \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\", \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\", \"                    doneNP = (!doneN) || (!doneP);\", \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\", \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\", \"/*--------------------------------------------------------------------------*/\", \"                    #if (FXAA_QUALITY_PS > 12)\", \"                    if(doneNP) {\", \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                        doneN = abs(lumaEndN) >= gradientScaled;\", \"                        doneP = abs(lumaEndP) >= gradientScaled;\", \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\", \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\", \"                        doneNP = (!doneN) || (!doneP);\", \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\", \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\", \"/*--------------------------------------------------------------------------*/\", \"                    }\", \"                    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                }\", \"                #endif\", \"/*--------------------------------------------------------------------------*/\", \"            }\", \"            #endif\", \"/*--------------------------------------------------------------------------*/\", \"        }\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    }\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                        }\", \"                        #endif\", \"/*--------------------------------------------------------------------------*/\", \"                    }\", \"                    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                }\", \"                #endif\", \"/*--------------------------------------------------------------------------*/\", \"            }\", \"            #endif\", \"/*--------------------------------------------------------------------------*/\", \"        }\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    }\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat dstN = posM.x - posN.x;\", \"    FxaaFloat dstP = posP.x - posM.x;\", \"    if(!horzSpan) dstN = posM.y - posN.y;\", \"    if(!horzSpan) dstP = posP.y - posM.y;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\", \"    FxaaFloat spanLength = (dstP + dstN);\", \"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\", \"    FxaaFloat spanLengthRcp = 1.0/spanLength;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaBool directionN = dstN < dstP;\", \"    FxaaFloat dst = min(dstN, dstP);\", \"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\", \"    FxaaFloat subpixG = subpixF * subpixF;\", \"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\", \"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\", \"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\", \"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\", \"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\", \"    #if (FXAA_DISCARD == 1)\", \"        return FxaaTexTop(tex, posM);\", \"    #else\", \"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\", \"    #endif\", \"}\", \"/*==========================================================================*/\", \"#endif\", \"\", \"void main() {\", \"  gl_FragColor = FxaaPixelShader(\", \"    vUv,\", \"    vec4(0.0),\", \"    tDiffuse,\", \"    tDiffuse,\", \"    tDiffuse,\", \"    resolution,\", \"    vec4(0.0),\", \"    vec4(0.0),\", \"    vec4(0.0),\", \"    0.75,\", \"    0.166,\", \"    0.0833,\", \"    0.0,\", \"    0.0,\", \"    0.0,\", \"    vec4(0.0)\", \"  );\", \"\", \"  // TODO avoid querying texture twice for same texel\", \"  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\", \"}\"].join(\"\\n\")\n\n};\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/FXAA.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/LuminosityHighPassShader.js":
/*!***************************************************************!*\
  !*** ./lib/js/lib/postprocessing/LuminosityHighPassShader.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author bhouston / http://clara.io/\r\n *\r\n * Luminosity\r\n * http://en.wikipedia.org/wiki/Luminosity\r\n */\n\nTHREE.LuminosityHighPassShader = {\n\n\t\tshaderID: \"luminosityHighPass\",\n\n\t\tuniforms: {\n\n\t\t\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\t\t\"luminosityThreshold\": { type: \"f\", value: 1.0 },\n\t\t\t\t\"smoothWidth\": { type: \"f\", value: 1.0 },\n\t\t\t\t\"defaultColor\": { type: \"c\", value: new THREE.Color(0x000000) },\n\t\t\t\t\"defaultOpacity\": { type: \"f\", value: 0.0 }\n\n\t\t},\n\n\t\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\t\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec3 defaultColor;\", \"uniform float defaultOpacity;\", \"uniform float luminosityThreshold;\", \"uniform float smoothWidth;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec3 luma = vec3( 0.299, 0.587, 0.114 );\", \"float v = dot( texel.xyz, luma );\", \"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\", \"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\", \"gl_FragColor = mix( outputColor, texel, alpha );\", \"}\"].join(\"\\n\")\n\n};\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/LuminosityHighPassShader.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/Mechanics.js":
/*!************************************************!*\
  !*** ./lib/js/lib/postprocessing/Mechanics.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n  @author meatbags / https://github.com/meatbags\r\n  **/\n\nTHREE.MechanicsShader = {\n  uniforms: {\n    'time': { value: 0.0 },\n    'width': { value: 100.0 },\n    'height': { value: 100.0 },\n    'tDiffuse': { value: null }\n  },\n  vertexShader: `\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    #define PI 3.14159\n    #define UV_SCALE 0.02\n    #define MAX_HEIGHT 6.0\n\n    varying vec2 vUv;\n    uniform sampler2D tDiffuse;\n    uniform float time;\n\n    float rand(vec2 seed) {\n      return fract(sin(dot(seed.xy, vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    vec2 randVec2() {\n      return vec2(rand(vUv + time), rand(vUv + time + 1.));\n    }\n\n    vec3 getPosition(vec2 coords) {\n      vec4 sample = texture2D(tDiffuse, coords);\n      vec3 res = vec3(coords.x / UV_SCALE, sample.y * MAX_HEIGHT, coords.y / UV_SCALE);\n      return res;\n    }\n\n    float computeAO(vec2 uvOff, vec3 P, vec3 N) {\n      vec3 Vpos = getPosition(vUv + uvOff * UV_SCALE) - P;\n      vec3 Vnorm = normalize(Vpos);\n      float dist = length(Vpos);\n      return max(dot(N, Vnorm) * (1.0 / (1.0 + dist)), 0.0);\n    }\n\n    float sampleAO(vec3 P) {\n      vec3 N = vec3(0., 1., 0.);\n      vec2 randOffset = randVec2();\n      const int iterations = 4;\n      float totalAO = 0.0;\n\n      for (int i=0; i<iterations; i++) {\n        vec2 coord1 = reflect(vec2(\n          (i < 2) ? ((i == 0) ? 1.0 : -1.0) : 0.0,\n          (i > 1) ? ((i == 2) ? 1.0 : -1.0) : 0.0\n        ), randOffset);\n        vec2 coord2 = vec2(\n          coord1.x * 0.707 - coord1.y * 0.707,\n          coord1.x * 0.707 + coord1.y * 0.707\n        );\n        totalAO += computeAO(coord1 * 0.25, P, N);\n        totalAO += computeAO(coord2 * 0.5, P, N);\n        totalAO += computeAO(coord1 * 0.75, P, N);\n        totalAO += computeAO(coord2, P, N);\n      }\n\n      return (totalAO / (float(iterations) * 4.));\n    }\n\n    void main() {\n      vec4 tex = texture2D(tDiffuse, vUv);\n      vec3 P = getPosition(vUv);\n      float ao = sampleAO(P);\n      vec4 frag = tex - ao * 0.25;\n\n      gl_FragColor = frag;\n    }\n  `\n};\n\n// render pass\nTHREE.MechanicsPass = function (size) {\n  THREE.Pass.call(this);\n\n  this.shader = THREE.MechanicsShader;\n  this.material = new THREE.ShaderMaterial(this.shader);\n  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  this.scene = new THREE.Scene();\n  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.material);\n  this.quad.frustumCulled = false;\n  this.scene.add(this.quad);\n  this.time = 0;\n};\n\nTHREE.MechanicsPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n  constructor: THREE.MechanicsPass,\n  render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n    this.shader.uniforms['tDiffuse'].value = readBuffer.texture;\n    this.time = (this.time + delta) % 10.;\n    this.shader.uniforms['time'].value = this.time;\n\n    if (this.renderToScreen) {\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.render(this.scene, this.camera, writeBuffer, this.clear);\n    }\n  }\n});\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/Mechanics.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/RenderPass.js":
/*!*************************************************!*\
  !*** ./lib/js/lib/postprocessing/RenderPass.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {\n\n\t\tTHREE.Pass.call(this);\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.overrideMaterial = overrideMaterial;\n\n\t\tthis.clearColor = clearColor;\n\t\tthis.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\t\tthis.clear = true;\n\t\tthis.clearDepth = false;\n\t\tthis.needsSwap = false;\n};\n\nTHREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n\n\t\tconstructor: THREE.RenderPass,\n\n\t\trender: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t\t\tvar oldClearColor, oldClearAlpha;\n\n\t\t\t\tif (this.clearColor) {\n\n\t\t\t\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\t\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\t\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t\t\t}\n\n\t\t\t\tif (this.clearDepth) {\n\n\t\t\t\t\t\trenderer.clearDepth();\n\t\t\t\t}\n\n\t\t\t\trenderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);\n\n\t\t\t\tif (this.clearColor) {\n\n\t\t\t\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t\t\t}\n\n\t\t\t\tthis.scene.overrideMaterial = null;\n\t\t\t\trenderer.autoClear = oldAutoClear;\n\t\t}\n\n});\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/RenderPass.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/ShaderPass.js":
/*!*************************************************!*\
  !*** ./lib/js/lib/postprocessing/ShaderPass.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.ShaderPass = function (shader, textureID) {\n\n\tTHREE.Pass.call(this);\n\n\tthis.textureID = textureID !== undefined ? textureID : \"tDiffuse\";\n\n\tif (shader instanceof THREE.ShaderMaterial) {\n\n\t\tthis.uniforms = shader.uniforms;\n\n\t\tthis.material = shader;\n\t} else if (shader) {\n\n\t\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\tthis.material = new THREE.ShaderMaterial({\n\n\t\t\tdefines: shader.defines || {},\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t});\n\t}\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nTHREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n\n\tconstructor: THREE.ShaderPass,\n\n\trender: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tif (this.uniforms[this.textureID]) {\n\n\t\t\tthis.uniforms[this.textureID].value = readBuffer.texture;\n\t\t}\n\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t}\n\n});\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/ShaderPass.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/UnrealBloomPass.js":
/*!******************************************************!*\
  !*** ./lib/js/lib/postprocessing/UnrealBloomPass.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author spidersharma / http://eduperiment.com/\r\n *\r\n * Inspired from Unreal Engine\r\n * https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\r\n */\nTHREE.UnrealBloomPass = function (resolution, strength, radius, threshold) {\n\n\tTHREE.Pass.call(this);\n\n\tthis.strength = strength !== undefined ? strength : 1;\n\tthis.radius = radius;\n\tthis.threshold = threshold;\n\tthis.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n\n\t// render targets\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\tthis.renderTargetsHorizontal = [];\n\tthis.renderTargetsVertical = [];\n\tthis.nMips = 5;\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tthis.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTarget.texture.name = \"UnrealBloomPass.h\" + i;\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsHorizontal.push(renderTarget);\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTarget.texture.name = \"UnrealBloomPass.v\" + i;\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsVertical.push(renderTarget);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// luminosity high pass material\n\n\tif (THREE.LuminosityHighPassShader === undefined) console.error(\"THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader\");\n\n\tvar highPassShader = THREE.LuminosityHighPassShader;\n\tthis.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);\n\n\tthis.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n\tthis.highPassUniforms[\"smoothWidth\"].value = 0.01;\n\n\tthis.materialHighPassFilter = new THREE.ShaderMaterial({\n\t\tuniforms: this.highPassUniforms,\n\t\tvertexShader: highPassShader.vertexShader,\n\t\tfragmentShader: highPassShader.fragmentShader,\n\t\tdefines: {}\n\t});\n\n\t// Gaussian Blur Materials\n\tthis.separableBlurMaterials = [];\n\tvar kernelSizeArray = [3, 5, 7, 9, 11];\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tthis.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n\n\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// Composite material\n\tthis.compositeMaterial = this.getCompositeMaterial(this.nMips);\n\tthis.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n\tthis.compositeMaterial.needsUpdate = true;\n\n\tvar bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n\tthis.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n\tthis.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];\n\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t// copy material\n\tif (THREE.CopyShader === undefined) {\n\n\t\tconsole.error(\"THREE.BloomPass relies on THREE.CopyShader\");\n\t}\n\n\tvar copyShader = THREE.CopyShader;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\tthis.copyUniforms[\"opacity\"].value = 1.0;\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t});\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.basic = new THREE.MeshBasicMaterial();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nTHREE.UnrealBloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n\n\tconstructor: THREE.UnrealBloomPass,\n\n\tdispose: function () {\n\n\t\tfor (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].dispose();\n\t\t}\n\n\t\tfor (var i = 0; i < this.renderTargetsVertical.length; i++) {\n\n\t\t\tthis.renderTargetsVertical[i].dispose();\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\t},\n\n\tsetSize: function (width, height) {\n\n\t\tvar resx = Math.round(width / 2);\n\t\tvar resy = Math.round(height / 2);\n\n\t\tthis.renderTargetBright.setSize(resx, resy);\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].setSize(resx, resy);\n\t\t\tthis.renderTargetsVertical[i].setSize(resx, resy);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\t\tresx = Math.round(resx / 2);\n\t\t\tresy = Math.round(resy / 2);\n\t\t}\n\t},\n\n\trender: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor(new THREE.Color(0, 0, 0), 0);\n\n\t\tif (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\n\n\t\t// Render input to screen\n\n\t\tif (this.renderToScreen) {\n\n\t\t\tthis.quad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.render(this.scene, this.camera, undefined, true);\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n\t\tthis.quad.material = this.materialHighPassFilter;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetBright, true);\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tvar inputRenderTarget = this.renderTargetBright;\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.quad.material = this.separableBlurMaterials[i];\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetsHorizontal[i], true);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetsVertical[i], true);\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[i];\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.quad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetsHorizontal[0], true);\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.quad.material = this.materialCopy;\n\t\tthis.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n\n\t\tif (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera, undefined, false);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, readBuffer, false);\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n\t\trenderer.autoClear = oldAutoClear;\n\t},\n\n\tgetSeperableBlurMaterial: function (kernelRadius) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"KERNEL_RADIUS\": kernelRadius,\n\t\t\t\t\"SIGMA\": kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"direction\": { value: new THREE.Vector2(0.5, 0.5) }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"#include <common>\\\r\n\t\t\t\tvarying vec2 vUv;\\n\\\r\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\r\n\t\t\t\tuniform vec2 texSize;\\\r\n\t\t\t\tuniform vec2 direction;\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\r\n\t\t\t\t}\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\r\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\r\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\r\n\t\t\t\t\t\tfloat x = float(i);\\\r\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\r\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\r\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\r\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\r\n\t\t\t\t\t}\\\r\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\r\n\t\t\t\t}\"\n\t\t});\n\t},\n\n\tgetCompositeMaterial: function (nMips) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"NUM_MIPS\": nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"blurTexture1\": { value: null },\n\t\t\t\t\"blurTexture2\": { value: null },\n\t\t\t\t\"blurTexture3\": { value: null },\n\t\t\t\t\"blurTexture4\": { value: null },\n\t\t\t\t\"blurTexture5\": { value: null },\n\t\t\t\t\"dirtTexture\": { value: null },\n\t\t\t\t\"bloomStrength\": { value: 1.0 },\n\t\t\t\t\"bloomFactors\": { value: null },\n\t\t\t\t\"bloomTintColors\": { value: null },\n\t\t\t\t\"bloomRadius\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"varying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D blurTexture1;\\\r\n\t\t\t\tuniform sampler2D blurTexture2;\\\r\n\t\t\t\tuniform sampler2D blurTexture3;\\\r\n\t\t\t\tuniform sampler2D blurTexture4;\\\r\n\t\t\t\tuniform sampler2D blurTexture5;\\\r\n\t\t\t\tuniform sampler2D dirtTexture;\\\r\n\t\t\t\tuniform float bloomStrength;\\\r\n\t\t\t\tuniform float bloomRadius;\\\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\r\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\r\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\r\n\t\t\t\t}\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\r\n\t\t\t\t}\"\n\t\t});\n\t}\n\n});\n\nTHREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nTHREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/UnrealBloomPass.js?");

/***/ }),

/***/ "./lib/js/lib/postprocessing/index.js":
/*!********************************************!*\
  !*** ./lib/js/lib/postprocessing/index.js ***!
  \********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _CopyShader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CopyShader.js */ \"./lib/js/lib/postprocessing/CopyShader.js\");\n/* harmony import */ var _CopyShader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CopyShader_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectComposer.js */ \"./lib/js/lib/postprocessing/EffectComposer.js\");\n/* harmony import */ var _EffectComposer_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _DepthShader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DepthShader.js */ \"./lib/js/lib/postprocessing/DepthShader.js\");\n/* harmony import */ var _DepthShader_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_DepthShader_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _FXAA_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FXAA.js */ \"./lib/js/lib/postprocessing/FXAA.js\");\n/* harmony import */ var _FXAA_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_FXAA_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LuminosityHighPassShader.js */ \"./lib/js/lib/postprocessing/LuminosityHighPassShader.js\");\n/* harmony import */ var _LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _RenderPass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RenderPass.js */ \"./lib/js/lib/postprocessing/RenderPass.js\");\n/* harmony import */ var _RenderPass_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_RenderPass_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ShaderPass.js */ \"./lib/js/lib/postprocessing/ShaderPass.js\");\n/* harmony import */ var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_ShaderPass_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UnrealBloomPass.js */ \"./lib/js/lib/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var _UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _Mechanics_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Mechanics.js */ \"./lib/js/lib/postprocessing/Mechanics.js\");\n/* harmony import */ var _Mechanics_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_Mechanics_js__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://XB/./lib/js/lib/postprocessing/index.js?");

/***/ }),

/***/ "./lib/js/main.js":
/*!************************!*\
  !*** ./lib/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib */ \"./lib/js/lib/index.js\");\n/* harmony import */ var _3d_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./3d_grid */ \"./lib/js/3d_grid/index.js\");\n/* harmony import */ var _2d_grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./2d_grid */ \"./lib/js/2d_grid/index.js\");\n/* harmony import */ var _mini__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mini */ \"./lib/js/mini/index.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ \"./lib/js/util/index.js\");\n\n\n\n\n\n\nclass App {\n  constructor() {\n    this.grid3d = new _3d_grid__WEBPACK_IMPORTED_MODULE_1__[\"Grid3D\"]();\n    this.grid2d = new _2d_grid__WEBPACK_IMPORTED_MODULE_2__[\"Grid2D\"]();\n\n    // mini apps\n    this.chess = new _mini__WEBPACK_IMPORTED_MODULE_3__[\"Chess\"]();\n    this.piano = new _mini__WEBPACK_IMPORTED_MODULE_3__[\"Piano\"]();\n\n    // run\n    this.timer = new _util__WEBPACK_IMPORTED_MODULE_4__[\"Timer\"]();\n    this.events();\n    this.loop();\n  }\n\n  events() {\n    window.onresize = () => {\n      this.grid3d.resize();\n      this.grid2d.resize();\n    };\n    window.onmousemove = e => {\n      this.grid2d.handleMouse(e.clientX, e.clientY);\n      this.grid3d.handleMouse(e.clientX, e.clientY);\n    };\n    window.addEventListener('orientationchange', () => {\n      this.grid3d.resize();\n    });\n    window.onscroll = () => {\n      this.grid2d.onscroll();\n    };\n  }\n\n  loop() {\n    requestAnimationFrame(() => {\n      this.loop();\n    });\n    var delta = this.timer.update();\n    this.grid3d.update(delta);\n    this.grid2d.update(delta);\n  }\n}\n\nwindow.onload = () => {\n  var app = new App();\n};\n\n//# sourceURL=webpack://XB/./lib/js/main.js?");

/***/ }),

/***/ "./lib/js/maths/index.js":
/*!*******************************!*\
  !*** ./lib/js/maths/index.js ***!
  \*******************************/
/*! exports provided: dot2D, subVector, polarRotate2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vector */ \"./lib/js/maths/vector.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"dot2D\", function() { return _vector__WEBPACK_IMPORTED_MODULE_0__[\"dot2D\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"subVector\", function() { return _vector__WEBPACK_IMPORTED_MODULE_0__[\"subVector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"polarRotate2D\", function() { return _vector__WEBPACK_IMPORTED_MODULE_0__[\"polarRotate2D\"]; });\n\n\n\n//# sourceURL=webpack://XB/./lib/js/maths/index.js?");

/***/ }),

/***/ "./lib/js/maths/vector.js":
/*!********************************!*\
  !*** ./lib/js/maths/vector.js ***!
  \********************************/
/*! exports provided: dot2D, subVector, polarRotate2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot2D\", function() { return dot2D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subVector\", function() { return subVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"polarRotate2D\", function() { return polarRotate2D; });\n/**\r\n * Some vector maths funcs.\r\n */\n\nfunction dot2D(a, b) {\n  return a.x * b.x + a.z * b.z;\n}\n\nfunction subVector(a, b) {\n  return new THREE.Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n\n//function isFacing(from, to, norm) {\n// check if dot product [from->to, norm] >= 0\n//return (((to.x - from.x) * norm.x) + ((to.z - from.z) * norm.z) >= 0);\n//};\n\nfunction polarRotate2D(point, angle) {\n  const theta = Math.atan2(point.y, point.x) + angle;\n  const mag = Math.sqrt(point.x * point.x + point.y * point.y);\n  point.x = Math.cos(theta) * mag;\n  point.y = Math.sin(theta) * mag;\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/maths/vector.js?");

/***/ }),

/***/ "./lib/js/mini/chess.js":
/*!******************************!*\
  !*** ./lib/js/mini/chess.js ***!
  \******************************/
/*! exports provided: Chess */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chess\", function() { return Chess; });\n/**\r\n * Playable chess board.\r\n */\n\nclass Chess {\n  constructor() {\n    this.root = document.querySelector('.chess');\n    this.board = document.querySelector('.chess-board ul');\n    this.boardReset = document.querySelector('.chess-reset-board ul');\n    document.querySelectorAll('.chess .reset').forEach(e => {\n      e.onclick = () => {\n        this.reset();\n      };\n    });\n    this.setEvents();\n  }\n\n  onClick(e) {\n    const active = this.root.querySelector('li.active');\n    if (active) {\n      e.currentTarget.innerHTML = active.innerHTML;\n      active.classList.remove('active');\n      active.innerHTML = '';\n    } else {\n      e.currentTarget.classList.add('active');\n    }\n  }\n\n  setEvents() {\n    document.querySelectorAll('.chess li').forEach(e => {\n      e.onclick = e => {\n        this.onClick(e);\n      };\n    });\n  }\n\n  reset() {\n    // reset the chess board\n    this.board.innerHTML = this.boardReset.innerHTML;\n    this.setEvents();\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/mini/chess.js?");

/***/ }),

/***/ "./lib/js/mini/index.js":
/*!******************************!*\
  !*** ./lib/js/mini/index.js ***!
  \******************************/
/*! exports provided: Piano, Chess */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _piano__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piano */ \"./lib/js/mini/piano.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Piano\", function() { return _piano__WEBPACK_IMPORTED_MODULE_0__[\"Piano\"]; });\n\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chess */ \"./lib/js/mini/chess.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Chess\", function() { return _chess__WEBPACK_IMPORTED_MODULE_1__[\"Chess\"]; });\n\n\n\n\n//# sourceURL=webpack://XB/./lib/js/mini/index.js?");

/***/ }),

/***/ "./lib/js/mini/piano.js":
/*!******************************!*\
  !*** ./lib/js/mini/piano.js ***!
  \******************************/
/*! exports provided: Piano */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Piano\", function() { return Piano; });\n/**\r\n * Playable piano.\r\n */\n\nclass Piano {\n  constructor() {\n    this.ready = false;\n    this.volume = 50;\n    this.baseSemitone = 60;\n\n    MIDI.loadPlugin({\n      soundfontUrl: themePath + '/lib/sound/',\n      instrument: 'acoustic_grand_piano',\n      onprogress: (state, progress) => {},\n      onsuccess: () => {\n        this.ready = true;\n      }\n    });\n\n    // assign key indices\n    var whiteKey = 0;\n    var blackKey = 0;\n    document.querySelectorAll('.keys-white li, .keys-black li').forEach(e => {\n      e.addEventListener('mouseenter', e => {\n        this.playKey(e);\n      });\n      e.addEventListener('click', e => {\n        this.playKey(e);\n      });\n      e.dataset.index = e.parentNode.classList.contains('keys-white') ? whiteKey++ : blackKey++;\n    });\n  }\n\n  playKey(e) {\n    if (this.ready) {\n      const index = e.currentTarget.dataset.index;\n      var tone = this.baseSemitone;\n      var mod = Math.floor(index / 7);\n\n      // get correct semitone\n      if (e.currentTarget.parentNode.classList.contains('keys-white')) {\n        tone += index * 2 - mod;\n        if (index > 2) {\n          tone -= index % 7 > 2 ? mod + 1 : mod;\n        }\n      } else {\n        tone += 1 + index * 2 - mod;\n        if (index > 1) {\n          tone -= index % 7 > 1 ? mod + 1 : mod;\n        }\n      }\n\n      // play note\n      MIDI.setVolume(0, this.volume);\n      MIDI.noteOn(0, tone, 10, 0);\n      MIDI.noteOff(0, tone, 0.1);\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/mini/piano.js?");

/***/ }),

/***/ "./lib/js/util/index.js":
/*!******************************!*\
  !*** ./lib/js/util/index.js ***!
  \******************************/
/*! exports provided: Timer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer */ \"./lib/js/util/timer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Timer\", function() { return _timer__WEBPACK_IMPORTED_MODULE_0__[\"Timer\"]; });\n\n\n\n//# sourceURL=webpack://XB/./lib/js/util/index.js?");

/***/ }),

/***/ "./lib/js/util/timer.js":
/*!******************************!*\
  !*** ./lib/js/util/timer.js ***!
  \******************************/
/*! exports provided: Timer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Timer\", function() { return Timer; });\nclass Timer {\n  constructor() {\n    this.now = new Date().getTime();\n    this.then = this.now;\n    this.delta = 0;\n  }\n\n  update() {\n    this.now = new Date().getTime();\n    this.delta = (this.now - this.then) / 1000.0;\n    this.then = this.now;\n    return this.delta;\n  }\n}\n\n\n\n//# sourceURL=webpack://XB/./lib/js/util/timer.js?");

/***/ })

/******/ });